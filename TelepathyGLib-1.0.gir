<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  --><repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.0">
  <include name="DBusGLib" version="1.0"/>
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="dbus-glib-1"/>
  <package name="gio-2.0"/>
  <namespace name="TelepathyGLib" version="0.11.2.1" shared-library="libtelepathy-glib.so.0" c:prefix="tp">
    <alias name="Handle" target="uint" c:type="TpHandle"/>
    <class name="Account" c:type="TpAccount" doc="The Telepathy Account Manager stores the user's configured real-time communication accounts. This object represents a stored account. If this account is deleted from the account manager, the #TpProxy::invalidated signal will be emitted with the domain %TP_DBUS_ERRORS and the error code %TP_DBUS_ERROR_OBJECT_REMOVED. One can connect to the #GObject::notify signal to get change notifications for many of the properties on this object. Refer to each property's documentation for whether it can be used in this way." version="0.7.32" parent="Proxy" glib:type-name="TpAccount" glib:get-type="tp_account_get_type" glib:type-struct="AccountClass">
      <constructor name="new" c:identifier="tp_account_new" doc="Convenience function to create a new account proxy. The returned #TpAccount is not guaranteed to be ready at the point of return." throws="1">
        <return-value transfer-ownership="full" doc=" not valid">
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core" c:identifier="tp_account_get_feature_quark_core" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="full" doc=" #TpAccount">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="parse_object_path" c:identifier="tp_account_parse_object_path" doc="Validates and parses a Telepathy Account's object path, extracting the connection manager's name, the protocol, and the account's unique identifier from the path. This includes replacing underscores with hyphens in the protocol name, as defined in the Account specification. Any of the out parameters may be %NULL if not needed. If %TRUE is returned, the caller is responsible for freeing the strings stored in any non-%NULL out parameters, using g_free()." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cm" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="account_id" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_account_init_known_interfaces" doc="Ensure that the known interfaces for TpAccount have been set up. This is done automatically when necessary, but for correct overriding of library interfaces by local extensions, you should call this function before calling tp_proxy_or_subclass_hook_on_interface_add() with first argument %TP_TYPE_ACCOUNT." version="0.7.32">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_connection" c:identifier="tp_account_get_connection" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="ensure_connection" c:identifier="tp_account_ensure_connection" doc="Set the connection of the account by specifying the connection object path. This function does not return a new ref and it is not guaranteed that the returned #TpConnection object is ready. The use-case for this function is in a HandleChannels callback and you already know the object path for the connection, so you can let @account create its #TpConnection and return it for use." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_display_name" c:identifier="tp_account_get_display_name" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_connection_manager" c:identifier="tp_account_get_connection_manager" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol" c:identifier="tp_account_get_protocol" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_icon_name" c:identifier="tp_account_get_icon_name" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="set_enabled_async" c:identifier="tp_account_set_enabled_async" doc="Requests an asynchronous set of the Enabled property of @account. When the operation is finished, @callback will be called. You can then call tp_account_set_enabled_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_finish" c:identifier="tp_account_set_enabled_finish" doc="Finishes an async set of the Enabled property." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_async" c:identifier="tp_account_reconnect_async" doc="Requests an asynchronous reconnect of @account. When the operation is finished, @callback will be called. You can then call tp_account_reconnect_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_finish" c:identifier="tp_account_reconnect_finish" doc="Finishes an async reconnect of @account." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_enabled" c:identifier="tp_account_is_enabled" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_valid" c:identifier="tp_account_is_valid" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="update_parameters_async" c:identifier="tp_account_update_parameters_async" doc="Requests an asynchronous update of parameters of @account. When the operation is finished, @callback will be called. You can then call tp_account_update_parameters_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameters" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
          <parameter name="unset_parameters" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="4">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_finish" c:identifier="tp_account_update_parameters_finish" doc="Finishes an async update of the parameters on @account." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="reconnect_required" transfer-ownership="none" doc=" to take effect">
            <type name="utf8" c:type="gchar***"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_async" c:identifier="tp_account_remove_async" doc="Requests an asynchronous removal of @account. When the operation is finished, @callback will be called. You can then call tp_account_remove_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish" c:identifier="tp_account_remove_finish" doc="Finishes an async removal of @account." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_async" c:identifier="tp_account_set_display_name_async" doc="Requests an asynchronous set of the DisplayName property of @account. When the operation is finished, @callback will be called. You can then call tp_account_set_display_name_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_finish" c:identifier="tp_account_set_display_name_finish" doc="Finishes an async set of the DisplayName property." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_async" c:identifier="tp_account_set_icon_name_async" doc="Requests an asynchronous set of the Icon property of @account. When the operation is finished, @callback will be called. You can then call tp_account_set_icon_name_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="icon_name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_finish" c:identifier="tp_account_set_icon_name_finish" doc="Finishes an async set of the Icon parameter." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_async" c:identifier="tp_account_request_presence_async" doc="Requests an asynchronous change of presence on @account. When the operation is finished, @callback will be called. You can then call tp_account_request_presence_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="5">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_finish" c:identifier="tp_account_request_presence_finish" doc="Finishes an async presence change request on @account." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connect_automatically" c:identifier="tp_account_get_connect_automatically" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_connect_automatically_async" c:identifier="tp_account_set_connect_automatically_async" doc="Requests an asynchronous set of the ConnectAutomatically property of then call tp_account_set_display_name_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connect_automatically" transfer-ownership="none">
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_finish" c:identifier="tp_account_set_connect_automatically_finish" doc="Finishes an async set of the ConnectAutomatically property." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_has_been_online" c:identifier="tp_account_get_has_been_online" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_connection_status" c:identifier="tp_account_get_connection_status" doc="Gets the connection status and reason from @account. The two values are the same as the #TpAccount:connection-status and #TpAccount:connection-status-reason properties." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <type name="ConnectionStatusReason" c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_presence" c:identifier="tp_account_get_current_presence" doc="Gets the current presence, status and status message of @account. These values are the same as the #TpAccount:current-presence-type, #TpAccount:current-status and #TpAccount:current-status-message properties." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status" direction="out" transfer-ownership="none" doc="return location for the current status">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message" direction="out" transfer-ownership="none" doc="return location for the current status message">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_requested_presence" c:identifier="tp_account_get_requested_presence" doc="Gets the requested presence, status and status message of @account. These values are the same as the #TpAccount:requested-presence-type, #TpAccount:requested-status and #TpAccount:requested-status-message properties." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="status_message" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_parameters" c:identifier="tp_account_get_parameters" doc="Returns the parameters of the account, in a hash table where each string is the parameter name (account, password, require-encryption etc.), and each value is a #GValue. Using the tp_asv_get family of functions (tp_asv_get_uint32(), tp_asv_get_string() etc.) to access the parameters is recommended. The allowed parameters depend on the connection manager, and can be found via tp_connection_manager_get_protocol() and tp_connection_manager_protocol_get_param(). Well-known parameters are listed &lt;ulink url=&quot;http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.ConnectionManager.html#org.freedesktop.Telepathy.ConnectionManager.RequestConnection&quot;&gt;in the Telepathy D-Bus Interface Specification&lt;/ulink&gt;." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </return-value>
      </method>
      <method name="get_nickname" c:identifier="tp_account_get_nickname" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="set_nickname_async" c:identifier="tp_account_set_nickname_async" doc="Requests an asynchronous change of the Nickname parameter on @account. When the operation is finished, @callback will be called. You can then call tp_account_set_nickname_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_finish" c:identifier="tp_account_set_nickname_finish" doc="Finishes an async nickname change request on @account." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_async" c:identifier="tp_account_get_avatar_async" doc="Requests an asynchronous get of @account's avatar. When the operation is finished, @callback will be called. You can then call tp_account_get_avatar_finish() to get the result of the operation." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="2">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_finish" c:identifier="tp_account_get_avatar_finish" doc="Finishes an async get operation of @account's avatar." version="0.9.0" throws="1">
        <return-value transfer-ownership="none" doc=" or %NULL on failure">
          <type name="GLib.Array" c:type="GArray*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared" c:identifier="tp_account_is_prepared" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async" c:identifier="tp_account_prepare_async" doc="Requests an asynchronous preparation of @account with the features specified by @features. When the operation is finished, @callback will be called. You can then call tp_account_prepare_finish() to get the result of the operation. If @features is %NULL, then @callback will be called when the implied %TP_ACCOUNT_FEATURE_CORE feature is ready. If %NULL is given to @callback, then no callback will be called when the operation is finished. Instead, it will simply set @features on @manager. Note that if @callback is %NULL, then @user_data must also be %NULL." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <type name="GLib.Quark" c:type="GQuark*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish" c:identifier="tp_account_prepare_finish" doc="Finishes an async preparation of the account @account." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_async" c:identifier="tp_account_set_avatar_async" doc="Requests an asynchronous change of the Avatar parameter on @self. When the operation is finished, @callback will be called. You can then call tp_account_set_avatar_finish() to get the result of the operation. If @len equals 0, the avatar is cleared." version="0.11.1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="avatar" transfer-ownership="none">
            <array c:type="guchar*">
              <type name="uint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="size_t" c:type="gsize"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="5">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_finish" c:identifier="tp_account_set_avatar_finish" doc="Finishes an async avatar change request on @account." version="0.11.1" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="connect-automatically" version="0.9.0" doc="Whether the account should connect automatically or not. To change this property, use tp_account_set_connect_automatically_async(). One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %FALSE.">
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="connection" version="0.9.0" doc="The connection of the account, or NULL if account is offline. It is not guaranteed that the returned #TpConnection object is ready. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %NULL.">
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="connection-manager" version="0.9.0" doc="The account's connection manager name.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="connection-status" version="0.9.0" doc="The account's connection status type (a %TpConnectionStatus). One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %TP_CONNECTION_STATUS_DISCONNECTED.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="connection-status-reason" version="0.9.0" doc="The account's connection status reason (a %TpConnectionStatusReason). One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="current-presence-type" version="0.9.0" doc="The account connection's current presence type (a %TpConnectionPresenceType). One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %TP_CONNECTION_PRESENCE_TYPE_UNSET.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="current-status" version="0.9.0" doc="The current Status string of the account. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %NULL.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="current-status-message" version="0.9.0" doc="The current status message message of the account. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %NULL.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="display-name" version="0.9.0" doc="The account's display name, from the DisplayName property. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %NULL.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="enabled" version="0.9.0" doc="Whether this account is enabled or not. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is FALSE.">
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="has-been-online" version="0.9.0" doc="Whether this account has been online or not. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %FALSE.">
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="icon-name" version="0.9.0" doc="The account's icon name. To change this propery, use tp_account_set_icon_name_async(). One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %NULL.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="nickname">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="protocol" version="0.9.0" doc="The account's protocol name.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="requested-presence-type" version="0.9.0" doc="The account's requested presence type (a #TpConnectionPresenceType). One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="requested-status" version="0.9.0" doc="The requested Status string of the account. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="requested-status-message" version="0.9.0" doc="The requested status message message of the account. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="valid" version="0.9.0" doc="Whether this account is valid. One can receive change notifications on this property by connecting to the #GObject::notify signal and using this property as the signal detail. This is not guaranteed to have been retrieved until tp_account_prepare_async() has finished; until then, the value is %FALSE.">
        <type name="boolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="AccountPrivate" c:type="TpAccountPrivate*"/>
      </field>
      <glib:signal name="presence-changed" doc="Emitted when the presence of the account changes." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="status_message" transfer-ownership="none">
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="status-changed" doc="Emitted when the connection status on the account changes." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_status" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="new_status" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="dbus_error_name" transfer-ownership="none" doc=" on a connection error in the future">
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="details" transfer-ownership="none" doc=" on a connection error in the future">
            <type name="GLib.HashTable" c:type="GHashTable"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountClass" c:type="TpAccountClass" glib:is-gtype-struct-for="Account" doc="The class of a #TpAccount.">
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="AccountClassPrivate" c:type="TpAccountClassPrivate*"/>
      </field>
    </record>
    <record name="AccountClassPrivate" c:type="TpAccountClassPrivate">
    </record>
    <class name="AccountManager" c:type="TpAccountManager" doc="The Telepathy Account Manager stores real-time communication accounts and their configuration, places accounts online on request, and manipulates accounts' presence, nicknames and avatars." version="0.7.32" parent="Proxy" glib:type-name="TpAccountManager" glib:get-type="tp_account_manager_get_type" glib:type-struct="AccountManagerClass">
      <constructor name="new" c:identifier="tp_account_manager_new" doc="Convenience function to create a new account manager proxy. The returned #TpAccountManager is not guaranteed to be ready on return. Use tp_account_manager_dup() instead if you want an account manager proxy on the starter or session bus (which is almost always the right thing for Telepathy).">
        <return-value transfer-ownership="full">
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core" c:identifier="tp_account_manager_get_feature_quark_core" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="full" doc=" #TpAccountManager">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="dup" c:identifier="tp_account_manager_dup" doc="Returns an account manager proxy on the D-Bus daemon on which this process was activated (if it was launched by D-Bus service activation), or the session bus (otherwise). The returned #TpAccountManager is cached; the same #TpAccountManager object will be returned by this function repeatedly, as long as at least one reference exists. Note that the returned #TpAccountManager is not guaranteed to be ready on return." version="0.9.0">
        <return-value transfer-ownership="full" doc=" if it wasn't possible to get a dbus daemon proxy for the appropriate bus">
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_account_manager_init_known_interfaces" doc="Ensure that the known interfaces for TpAccountManager have been set up. This is done automatically when necessary, but for correct overriding of library interfaces by local extensions, you should call this function before calling tp_proxy_or_subclass_hook_on_interface_add() with first argument %TP_TYPE_ACCOUNT_MANAGER." version="0.7.32">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="ensure_account" c:identifier="tp_account_manager_ensure_account" doc="Lookup an account in the account manager @manager. If the desired account has already been ensured then the same object will be returned, otherwise it will create a new #TpAccount and add it to @manager. As a result, if to be ready on return. The caller must keep a ref to the returned object using g_object_ref() if it is to be kept." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_accounts" c:identifier="tp_account_manager_get_valid_accounts" doc="Returns a newly allocated #GList of valid accounts in @manager. The list must be freed with g_list_free() after used. None of the accounts in the returned list are guaranteed to be ready. Note that the #TpAccount&lt;!-- --&gt;s in the returned #GList are not reffed before returning from this function. One could ref every item in the list like the following example: |[ GList *accounts; account = tp_account_manager_get_valid_accounts (manager); g_list_foreach (accounts, (GFunc) g_object_ref, NULL); ]| The list of valid accounts returned is not guaranteed to have been retrieved until %TP_ACCOUNT_MANAGER_FEATURE_CORE is prepared (tp_account_manager_prepare_async() has returned). Until this feature has been prepared, an empty list (%NULL) will be returned." version="0.9.0">
        <return-value transfer-ownership="container" doc="a newly allocated #GList of valid accounts in @manager">
          <type name="GLib.List" c:type="GList*">
            <type name="TelepathyGLib.Account"/>
          </type>
        </return-value>
      </method>
      <method name="set_all_requested_presences" c:identifier="tp_account_manager_set_all_requested_presences" doc="Iterates through the accounts in @manager and requests the presence (@type, @status and @message). Note that the presence requested here is merely a request, and if might not be satisfiable. You can find the most available presence across all accounts by calling tp_account_manager_get_most_available_presence(). Setting a requested presence on all accounts will have no effect until tp_account_manager_prepare_async() has finished." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_most_available_presence" c:identifier="tp_account_manager_get_most_available_presence" doc="Gets the most available presence over all accounts in @manager. This function does not average presences across all accounts, but it merely finds the &quot;most available&quot; presence. As a result, there is a guarantee that there exists at least one account in @manager with the returned presence. If no accounts are enabled or valid the output will be (%TP_CONNECTION_PRESENCE_TYPE_OFFLINE, &quot;offline&quot;, &quot;&quot;). The return value of this function is not guaranteed to have been retrieved until tp_account_manager_prepare_async() has finished; until then, the value will be the same as if no accounts are enabled or valid." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_async" c:identifier="tp_account_manager_create_account_async" doc="Requests an asynchronous create of an account on the account manager then call tp_account_manager_create_account_finish() to get the result of the operation. %TP_ACCOUNT_FEATURE_CORE feature ready on it, so when calling tp_account_manager_create_account_finish(), one can guarantee this feature will be ready." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection_manager" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="async" closure="7">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_finish" c:identifier="tp_account_manager_create_account_finish" doc="Finishes an async create account operation, and returns a new #TpAccount object, with the %TP_ACCOUNT_FEATURE_CORE feature ready on it." version="0.9.0" throws="1">
        <return-value transfer-ownership="full" doc=" %NULL">
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared" c:identifier="tp_account_manager_is_prepared" doc="&lt;!-- --&gt;" version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async" c:identifier="tp_account_manager_prepare_async" doc="features, or %NULL Requests an asynchronous preparation of @manager with the features specified by @features. When the operation is finished, @callback will be called. You can then call tp_account_manager_prepare_finish() to get the result of the operation. If @features is %NULL, then @callback will be called when the implied %TP_ACCOUNT_MANAGER_FEATURE_CORE feature is ready. If %NULL is given to @callback, then no callback will be called when the operation is finished. Instead, it will simply set @features on @manager. Note that if @callback is %NULL, then @user_data must also be %NULL." version="0.9.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1" doc="a 0-terminated list of">
            <array c:type="GQuark*">
              <type name="GLib.Quark"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" allow-none="1" scope="async" closure="3" doc="a callback to call when the request is satisfied">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" allow-none="1" doc="data to pass to @callback">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish" c:identifier="tp_account_manager_prepare_finish" doc="Finishes an async preparation of the account manager @manager." version="0.9.0" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enable_restart" c:identifier="tp_account_manager_enable_restart" doc="Enable autostarting the account manager D-Bus service. This means that the account manager will be restarted if it disappears from the bus.">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="AccountManagerPrivate" c:type="TpAccountManagerPrivate*"/>
      </field>
      <glib:signal name="account-disabled" doc="Emitted when an account from @manager is disabled." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <type name="Account" c:type="TpAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-enabled" doc="Emitted when an account from @manager is enabled. Note that the returned #TpAccount @account is not guaranteed to have any features pre-prepared, including %TP_ACCOUNT_FEATURE_CORE." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <type name="Account" c:type="TpAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-removed" doc="Emitted when an account is removed from @manager." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <type name="Account" c:type="TpAccount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-validity-changed" doc="Emitted when the validity on @account changes. @account is not guaranteed to be ready when this signal is emitted." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <type name="Account" c:type="TpAccount"/>
          </parameter>
          <parameter name="valid" transfer-ownership="none">
            <type name="boolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="most-available-presence-changed" doc="Emitted when the most available presence on @manager changes." version="0.9.0">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountManagerClass" c:type="TpAccountManagerClass" glib:is-gtype-struct-for="AccountManager" doc="The class of a #TpAccount.">
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="AccountManagerClassPrivate" c:type="TpAccountManagerClassPrivate*"/>
      </field>
    </record>
    <record name="AccountManagerClassPrivate" c:type="TpAccountManagerClassPrivate">
    </record>
    <record name="AccountManagerPrivate" c:type="TpAccountManagerPrivate">
    </record>
    <record name="AccountPrivate" c:type="TpAccountPrivate">
    </record>
    <enumeration name="CMInfoSource" doc="Describes possible sources of information on connection managers' supported protocols." version="0.7.1" c:type="TpCMInfoSource">
      <member name="none" value="0" c:identifier="TP_CM_INFO_SOURCE_NONE"/>
      <member name="file" value="1" c:identifier="TP_CM_INFO_SOURCE_FILE"/>
      <member name="live" value="2" c:identifier="TP_CM_INFO_SOURCE_LIVE"/>
    </enumeration>
    <class name="Channel" c:type="TpChannel" doc="A proxy object for a Telepathy channel. A proxy object for a Telepathy channel. There are no interesting public struct fields. subclassing.)" version="0.7.1" parent="Proxy" glib:type-name="TpChannel" glib:get-type="tp_channel_get_type" glib:type-struct="ChannelClass">
      <constructor name="new" c:identifier="tp_channel_new" doc="&lt;!-- --&gt;" version="0.7.1" throws="1">
        <return-value transfer-ownership="full">
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="optional_channel_type" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="optional_handle_type" transfer-ownership="none" doc=" %TP_UNKNOWN_HANDLE_TYPE if not">
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="optional_handle" transfer-ownership="none" doc=" (if @optional_handle_type is %TP_UNKNOWN_HANDLE_TYPE or %TP_HANDLE_TYPE_NONE, this must be 0)">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_properties" c:identifier="tp_channel_new_from_properties" doc="&lt;!-- --&gt;" version="0.7.19" throws="1">
        <return-value transfer-ownership="full">
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none" doc=" as signalled by the NewChannel D-Bus signal or returned by the">
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces" c:identifier="tp_channel_init_known_interfaces" doc="Ensure that the known interfaces for TpChannel have been set up. This is done automatically when necessary, but for correct overriding of library interfaces by local extensions, you should call this function before calling tp_proxy_or_subclass_hook_on_interface_add() with first argument %TP_TYPE_CHANNEL." version="0.7.6">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="run_until_ready" c:identifier="tp_channel_run_until_ready" doc="If @self is ready for use (introspection has finished, etc.), return immediately. Otherwise, re-enter the main loop until the channel either becomes invalid or becomes ready for use, or until the main loop stored via @loop is cancelled." version="0.7.1" deprecated="Use tp_connection_call_when_ready," deprecated-version="0.11.0">
        <return-value transfer-ownership="none" doc=" %FALSE if the channel has become invalid.">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none" doc=" (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run">
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_when_ready" c:identifier="tp_channel_call_when_ready" doc="If @self is ready for use or has been invalidated, call @callback immediately, then return. Otherwise, arrange for @callback to be called when @self either becomes ready for use or becomes invalid." version="0.7.7">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="call" closure="2" doc=" happens first">
            <type name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready" c:identifier="tp_channel_is_ready" doc="Returns the same thing as the #TpChannel:channel-ready property." version="0.7.12">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_channel_type" c:identifier="tp_channel_get_channel_type" doc="Get the D-Bus interface name representing this channel's type, if it has been discovered. This is the same as the #TpChannel:channel-type property." version="0.7.12">
        <return-value transfer-ownership="none" doc=" type or %NULL, if the channel is not yet ready.">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_channel_type_id" c:identifier="tp_channel_get_channel_type_id" doc="Get the D-Bus interface name representing this channel's type, as a GQuark, if it has been discovered. This is the same as the #TpChannel:channel-type property, except that it is a GQuark rather than a string." version="0.7.12">
        <return-value transfer-ownership="full" doc=" type or 0, if the channel is not yet ready.">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </method>
      <method name="get_handle" c:identifier="tp_channel_get_handle" doc="Get the handle representing the contact, chatroom, etc. with which this channel communicates for its whole lifetime, or 0 if there is no such handle or it has not yet been discovered. This is the same as the #TpChannel:handle property. If %handle_type is not %NULL, the type of handle is written into it. This will be %TP_UNKNOWN_HANDLE_TYPE if the handle has not yet been discovered, or %TP_HANDLE_TYPE_NONE if there is no handle with which this channel will always communicate. This is the same as the #TpChannel:handle-type property." version="0.7.12">
        <return-value transfer-ownership="full">
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <type name="HandleType" c:type="TpHandleType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identifier" c:identifier="tp_channel_get_identifier" doc="This channel's associated identifier, or NULL if no identifier or unknown. The identifier is the result of inspecting #TpChannel:handle. This is the same as the #TpChannel:identifier property." version="0.7.21">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="borrow_connection" c:identifier="tp_channel_borrow_connection" doc="Returns the connection for this channel. The returned pointer is only valid while this channel is valid - reference it with g_object_ref() if needed." version="0.7.12">
        <return-value transfer-ownership="full">
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="borrow_immutable_properties" c:identifier="tp_channel_borrow_immutable_properties" doc="Returns the immutable D-Bus properties of this channel, the same as #TpChannel:channel-properties. The returned hash table should not be altered, and is not necessarily valid after the main loop is next re-entered. Copy it with g_boxed_copy() (its type is %TP_HASH_TYPE_QUALIFIED_PROPERTY_VALUE_MAP) if a copy that remains valid must be kept. If the #TpChannel:channel-properties property was not set during construction (e.g. by calling tp_channel_new_from_properties()), a reasonable but possibly incomplete version will be made up from the values of individual properties; reading this property repeatedly may yield progressively more complete values until #TpChannel:channel-ready becomes %TRUE.">
        <return-value transfer-ownership="full" doc=" D-Bus interface name + &quot;.&quot; + property name, and the values are #GValue instances">
          <type name="GLib.HashTable" c:type="GHashTable*"/>
        </return-value>
      </method>
      <method name="group_get_self_handle" c:identifier="tp_channel_group_get_self_handle">
        <return-value transfer-ownership="full">
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="group_get_flags" c:identifier="tp_channel_group_get_flags">
        <return-value transfer-ownership="full">
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </return-value>
      </method>
      <method name="group_get_members" c:identifier="tp_channel_group_get_members">
        <return-value transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="group_get_local_pending" c:identifier="tp_channel_group_get_local_pending">
        <return-value transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="group_get_remote_pending" c:identifier="tp_channel_group_get_remote_pending">
        <return-value transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </return-value>
      </method>
      <method name="group_get_local_pending_info" c:identifier="tp_channel_group_get_local_pending_info">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="local_pending" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="ChannelGroupChangeReason" c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_handle_owner" c:identifier="tp_channel_group_get_handle_owner">
        <return-value transfer-ownership="full">
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <property name="channel-ready" doc="Initially %FALSE; changes to %TRUE when introspection of the channel has finished and it's ready for use. By the time this property becomes %TRUE, the following will be true: - #TpChannel:channel-type set, unless introspection failed - #TpChannel:handle-type and #TpChannel:handle set, unless introspection failed - any extra interfaces will have been set up in TpProxy (i.e. #TpProxy:interfaces contains at least all extra Channel interfaces) In addition, if #TpProxy:interfaces includes the Group interface: - the initial value of the #TpChannel:group-self-handle property will have been fetched and change notification will have been set up - the initial value of the #TpChannel:group-flags property will have been fetched and change notification will have been set up Change notification is via notify::channel-ready.">
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="connection" writable="1" construct-only="1" doc="The #TpConnection to which this #TpChannel belongs. Used for e.g. handle manipulation.">
        <type name="Connection" c:type="TpConnection"/>
      </property>
      <property name="group-flags" version="0.7.12" doc="If this channel is ready (#TpChannel:channel-ready) and is a group, #TpChannelGroupFlags indicating the capabilities and behaviour of that group. Otherwise, 0. Change notification is via notify::group-flags or TpChannel::group-flags-changed.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="group-self-handle" version="0.7.12" doc="If this channel is ready (#TpChannel:channel-ready) and is a group, and the user is a member of it, the #TpHandle representing them in this group. Otherwise, either a handle representing the user, or 0. Change notification is via notify::group-self-handle.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="identifier" doc="This channel's associated identifier, or NULL if no identifier or unknown. The identifier is the result of inspecting #TpChannel:handle.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="ChannelPrivate" c:type="TpChannelPrivate*"/>
      </field>
      <glib:signal name="group-flags-changed" doc="Emitted when the #TpChannel:group-flags property changes while the channel is ready." version="0.7.12">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed" doc="Emitted when the group members change in a Group channel that is ready." version="0.7.12">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="gchararray"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none" doc=" local-pending or remote-pending) removed">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none" doc=" members added">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none" doc=" members added">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed-detailed" doc="Emitted when the group members change in a Group channel that is ready. Contains a superset of the information in the TpChannel::group-members-changed signal, and is emitted at the same time; applications can connect to this signal and ignore the other." version="0.7.21">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none" doc=" local-pending or remote-pending) removed">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none" doc=" members added">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none" doc=" members added">
            <type name="GLib.Array" c:type="GArray*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none" doc="to #GValue containing details about the change, as described in the specification of the MembersChangedDetailed signal.">
            <type name="GLib.HashTable" c:type="GHashTable*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="ChannelCallStateFlags" c:type="TpChannelCallStateFlags">
      <member name="ringing" value="1" c:identifier="TP_CHANNEL_CALL_STATE_RINGING"/>
      <member name="queued" value="2" c:identifier="TP_CHANNEL_CALL_STATE_QUEUED"/>
      <member name="held" value="4" c:identifier="TP_CHANNEL_CALL_STATE_HELD"/>
      <member name="forwarded" value="8" c:identifier="TP_CHANNEL_CALL_STATE_FORWARDED"/>
      <member name="in_progress" value="16" c:identifier="TP_CHANNEL_CALL_STATE_IN_PROGRESS"/>
    </enumeration>
    <enumeration name="ChannelChatState" c:type="TpChannelChatState">
      <member name="gone" value="0" c:identifier="TP_CHANNEL_CHAT_STATE_GONE"/>
      <member name="inactive" value="1" c:identifier="TP_CHANNEL_CHAT_STATE_INACTIVE"/>
      <member name="active" value="2" c:identifier="TP_CHANNEL_CHAT_STATE_ACTIVE"/>
      <member name="paused" value="3" c:identifier="TP_CHANNEL_CHAT_STATE_PAUSED"/>
      <member name="composing" value="4" c:identifier="TP_CHANNEL_CHAT_STATE_COMPOSING"/>
    </enumeration>
    <record name="ChannelClass" c:type="TpChannelClass" glib:is-gtype-struct-for="Channel" doc="The class of a #TpChannel. In addition to @parent_class there are four pointers reserved for possible future use. subclassing.)" version="0.7.1">
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <enumeration name="ChannelGroupChangeReason" c:type="TpChannelGroupChangeReason">
      <member name="none" value="0" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NONE"/>
      <member name="offline" value="1" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE"/>
      <member name="kicked" value="2" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_KICKED"/>
      <member name="busy" value="3" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BUSY"/>
      <member name="invited" value="4" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVITED"/>
      <member name="banned" value="5" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BANNED"/>
      <member name="error" value="6" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_ERROR"/>
      <member name="invalid_contact" value="7" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT"/>
      <member name="no_answer" value="8" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER"/>
      <member name="renamed" value="9" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED"/>
      <member name="permission_denied" value="10" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED"/>
      <member name="separated" value="11" c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED"/>
    </enumeration>
    <enumeration name="ChannelGroupFlags" c:type="TpChannelGroupFlags">
      <member name="can_add" value="1" c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_ADD"/>
      <member name="can_remove" value="2" c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_REMOVE"/>
      <member name="can_rescind" value="4" c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_RESCIND"/>
      <member name="message_add" value="8" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD"/>
      <member name="message_remove" value="16" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE"/>
      <member name="message_accept" value="32" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT"/>
      <member name="message_reject" value="64" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT"/>
      <member name="message_rescind" value="128" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND"/>
      <member name="channel_specific_handles" value="256" c:identifier="TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES"/>
      <member name="only_one_group" value="512" c:identifier="TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP"/>
      <member name="handle_owners_not_available" value="1024" c:identifier="TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE"/>
      <member name="properties" value="2048" c:identifier="TP_CHANNEL_GROUP_FLAG_PROPERTIES"/>
      <member name="members_changed_detailed" value="4096" c:identifier="TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED"/>
      <member name="message_depart" value="8192" c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_DEPART"/>
    </enumeration>
    <enumeration name="ChannelMediaCapabilities" c:type="TpChannelMediaCapabilities">
      <member name="audio" value="1" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_AUDIO"/>
      <member name="video" value="2" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_VIDEO"/>
      <member name="nat_traversal_stun" value="4" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN"/>
      <member name="nat_traversal_gtalk_p2p" value="8" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P"/>
      <member name="nat_traversal_ice_udp" value="16" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_ICE_UDP"/>
      <member name="immutable_streams" value="32" c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_IMMUTABLE_STREAMS"/>
    </enumeration>
    <enumeration name="ChannelPasswordFlags" c:type="TpChannelPasswordFlags">
      <member name="channel_password_flag_provide" value="8" c:identifier="TP_CHANNEL_PASSWORD_FLAG_PROVIDE"/>
    </enumeration>
    <record name="ChannelPrivate" c:type="TpChannelPrivate">
    </record>
    <enumeration name="ChannelTextMessageFlags" c:type="TpChannelTextMessageFlags">
      <member name="truncated" value="1" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED"/>
      <member name="non_text_content" value="2" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT"/>
      <member name="scrollback" value="4" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK"/>
      <member name="rescued" value="8" c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED"/>
    </enumeration>
    <enumeration name="ChannelTextMessageType" c:type="TpChannelTextMessageType">
      <member name="normal" value="0" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL"/>
      <member name="action" value="1" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION"/>
      <member name="notice" value="2" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE"/>
      <member name="auto_reply" value="3" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY"/>
      <member name="delivery_report" value="4" c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT"/>
    </enumeration>
    <enumeration name="ChannelTextSendError" c:type="TpChannelTextSendError">
      <member name="unknown" value="0" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN"/>
      <member name="offline" value="1" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE"/>
      <member name="invalid_contact" value="2" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT"/>
      <member name="permission_denied" value="3" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED"/>
      <member name="too_long" value="4" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG"/>
      <member name="not_implemented" value="5" c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED"/>
    </enumeration>
    <callback name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb" doc="Signature of a callback passed to tp_channel_call_when_ready(), which will be called exactly once, when the channel becomes ready or invalid (whichever happens first)">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none" doc=" if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)">
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none" doc=" it was invalidated if it is now invalid">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnMgrParamFlags" c:type="TpConnMgrParamFlags">
      <member name="required" value="1" c:identifier="TP_CONN_MGR_PARAM_FLAG_REQUIRED"/>
      <member name="register" value="2" c:identifier="TP_CONN_MGR_PARAM_FLAG_REGISTER"/>
      <member name="has_default" value="4" c:identifier="TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT"/>
      <member name="secret" value="8" c:identifier="TP_CONN_MGR_PARAM_FLAG_SECRET"/>
      <member name="dbus_property" value="16" c:identifier="TP_CONN_MGR_PARAM_FLAG_DBUS_PROPERTY"/>
    </enumeration>
    <class name="Connection" c:type="TpConnection" doc="A proxy object for a Telepathy connection. There are no interesting public struct fields. subclassing.)" version="0.7.1" parent="Proxy" glib:type-name="TpConnection" glib:get-type="tp_connection_get_type" glib:type-struct="ConnectionClass">
      <constructor name="new" c:identifier="tp_connection_new" doc="&lt;!-- --&gt;" version="0.7.1" throws="1">
        <return-value transfer-ownership="full" doc=" fails or on invalid arguments">
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bus_name" transfer-ownership="none" doc=" if well-known, this function will make a blocking call to the bus daemon to resolve the unique name. May be %NULL if @object_path is not, in which case a well-known name will be derived from @object_path.">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none" doc=" if @bus_name is a well-known name, in which case the object path will be derived from @bus_name.">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces" c:identifier="tp_connection_init_known_interfaces" doc="Ensure that the known interfaces for TpConnection have been set up. This is done automatically when necessary, but for correct overriding of library interfaces by local extensions, you should call this function before calling tp_proxy_or_subclass_hook_on_interface_add() with first argument %TP_TYPE_CONNECTION." version="0.7.6">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="presence_type_cmp_availability" c:identifier="tp_connection_presence_type_cmp_availability" doc="Compares @p1 and @p2 like strcmp(). @p1 &gt; @p2 means @p1 is more available than @p2. unknown &gt; unset" version="0.7.16">
        <return-value transfer-ownership="none">
          <type name="int" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="p1" transfer-ownership="none">
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_status" c:identifier="tp_connection_get_status" doc="If @reason is not %NULL it is set to the reason why &quot;status&quot; changed to its current value, or %TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown. don't know yet." version="0.7.14">
        <return-value transfer-ownership="full">
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <type name="ConnectionStatusReason" c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_self_handle" c:identifier="tp_connection_get_self_handle" doc="Return the %TP_HANDLE_TYPE_CONTACT handle of the local user on this connection, or 0 if the connection is not ready (the TpConnection:connection-ready property is false) or has become invalid (the TpProxy::invalidated signal). The returned handle is not necessarily valid forever (the notify::self-handle signal will be emitted if it changes, which can happen on protocols such as IRC). Construct a #TpContact object if you want to track the local user's identifier in the protocol, or other information like their presence status, over time." version="0.7.26">
        <return-value transfer-ownership="full">
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="is_ready" c:identifier="tp_connection_is_ready" doc="Returns the same thing as the #TpConnection:connection-ready property." version="0.7.17">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="run_until_ready" c:identifier="tp_connection_run_until_ready" doc="If @self is connected and ready for use, return immediately. Otherwise, call Connect() (unless @connect is %FALSE) and re-enter the main loop until the connection becomes invalid, the connection connects successfully and is introspected, or the main loop stored via @loop is cancelled." version="0.7.1" deprecated="Use tp_connection_call_when_ready," deprecated-version="0.11.0">
        <return-value transfer-ownership="none" doc=" %FALSE if the connection has become invalid.">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connect" transfer-ownership="none" doc="if it appears to be necessary; if %FALSE, rely on Connect() to be called by another client">
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none" doc=" (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run">
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_when_ready" c:identifier="tp_connection_call_when_ready" doc="If @self is ready for use or has been invalidated, call @callback immediately, then return. Otherwise, arrange for @callback to be called when @self either becomes ready for use or becomes invalid. Note that if the connection is not in state CONNECTED, the callback will not be called until the connection either goes to state CONNECTED or is invalidated (e.g. by going to state DISCONNECTED or by becoming unreferenced). In particular, this method does not call Connect(). Call tp_cli_connection_call_connect() too, if you want to do that." version="0.7.7">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="call" closure="2" doc=" whichever happens first">
            <type name="ConnectionWhenReadyCb" c:type="TpConnectionWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_object_path" c:identifier="tp_connection_parse_object_path" doc="connection If the object path of @connection is in the correct form, set return FALSE." version="0.7.27">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="cm_name" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="hold_handles" c:identifier="tp_connection_hold_handles">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="6" destroy="7">
            <type name="ConnectionHoldHandlesCb" c:type="TpConnectionHoldHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_handles" c:identifier="tp_connection_request_handles">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="5" destroy="6">
            <type name="ConnectionRequestHandlesCb" c:type="TpConnectionRequestHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_handles" c:identifier="tp_connection_unref_handles">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contact_attributes" c:identifier="tp_connection_get_contact_attributes">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <type name="boolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <property name="connection-ready" doc="Initially %FALSE; changes to %TRUE when the connection has gone to CONNECTED status, introspection has finished and it's ready for use. By the time this property becomes %TRUE, any extra interfaces will have been set up and the #TpProxy:interfaces property will have been populated.">
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="self-handle" doc="The %TP_HANDLE_TYPE_CONTACT handle of the local user on this connection, or 0 if we don't know yet or if the connection has become invalid.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="status" doc="This connection's status, or TP_UNKNOWN_CONNECTION_STATUS if we don't know yet.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="status-reason" doc="The reason why #TpConnection:status changed to its current value, or TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown. know yet.">
        <type name="uint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv">
        <type name="ConnectionPrivate" c:type="TpConnectionPrivate*"/>
      </field>
    </class>
    <enumeration name="ConnectionAliasFlags" c:type="TpConnectionAliasFlags">
      <member name="connection_alias_flag_user_set" value="1" c:identifier="TP_CONNECTION_ALIAS_FLAG_USER_SET"/>
    </enumeration>
    <enumeration name="ConnectionCapabilityFlags" c:type="TpConnectionCapabilityFlags">
      <member name="create" value="1" c:identifier="TP_CONNECTION_CAPABILITY_FLAG_CREATE"/>
      <member name="invite" value="2" c:identifier="TP_CONNECTION_CAPABILITY_FLAG_INVITE"/>
    </enumeration>
    <record name="ConnectionClass" c:type="TpConnectionClass" glib:is-gtype-struct-for="Connection" doc="The class of a #TpConnection. In addition to @parent_class there are four pointers reserved for possible future use. subclassing.)" version="0.7.1">
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="ConnectionHoldHandlesCb" c:type="TpConnectionHoldHandlesCb">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <type name="Handle" c:type="TpHandle*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ConnectionManager" c:type="TpConnectionManager" doc="A proxy object for a Telepathy connection manager. This might represent a connection manager which is currently running (in which case it can be introspected) or not (in which case its capabilities can be read from .manager files in the filesystem). Accordingly, this object never emits #TpProxy::invalidated unless all references to it are discarded. Various fields and methods on this object do not work until tp_connection_manager_is_ready() returns %TRUE. Use tp_connection_manager_call_when_ready() to wait for this to happen." version="0.7.1" parent="Proxy" glib:type-name="TpConnectionManager" glib:get-type="tp_connection_manager_get_type" glib:type-struct="ConnectionManagerClass">
      <constructor name="new" c:identifier="tp_connection_manager_new" doc="Convenience function to create a new connection manager proxy. If its protocol and parameter information are required, you should call tp_connection_manager_call_when_ready() on the result." throws="1">
        <return-value transfer-ownership="full" doc=" is set.">
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="manager_filename" transfer-ownership="none" doc=" (and generally should) be %NULL.">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="check_valid_name" c:identifier="tp_connection_manager_check_valid_name" doc="Check that the given string is a valid connection manager name, i.e. that it consists entirely of ASCII letters, digits and underscores, and starts with a letter." version="0.7.1" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="check_valid_protocol_name" c:identifier="tp_connection_manager_check_valid_protocol_name" doc="Check that the given string is a valid protocol name, i.e. that it consists entirely of ASCII letters, digits and hyphen/minus, and starts with a letter." version="0.7.1" throws="1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_connection_manager_init_known_interfaces" doc="Ensure that the known interfaces for TpConnectionManager have been set up. This is done automatically when necessary, but for correct overriding of library interfaces by local extensions, you should call this function before calling tp_proxy_or_subclass_hook_on_interface_add() with first argument %TP_TYPE_CONNECTION_MANAGER." version="0.7.32">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="activate" c:identifier="tp_connection_manager_activate" doc="Attempt to run and introspect the connection manager, asynchronously. Since 0.7.26 this function is not generally very useful, since the connection manager will now be activated automatically if necessary. If the CM was already running, do nothing and return %FALSE. On success, emit #TpConnectionManager::activated when the CM appears on the bus, and #TpConnectionManager::got-info when its capabilities have been (re-)discovered. On failure, emit #TpConnectionManager::exited without first emitting activated." version="0.7.1">
        <return-value transfer-ownership="none" doc=" if the connection manager was already running and no additional signals will be emitted.">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="call_when_ready" c:identifier="tp_connection_manager_call_when_ready" doc="Call the @callback from the main loop when information about @cm's supported protocols and parameters has been retrieved." version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3" doc=" error">
            <type name="ConnectionManagerWhenReadyCb" c:type="TpConnectionManagerWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none" doc=" will not be called, but @destroy will still be called">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="tp_connection_manager_get_name" doc="Return the internal name of this connection manager in the Telepathy D-Bus API, e.g. &quot;gabble&quot; or &quot;haze&quot;. This is often the name of the binary without the &quot;telepathy-&quot; prefix. The returned string is valid as long as @self is. Copy it with g_strdup() if a longer lifetime is required." version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_ready" c:identifier="tp_connection_manager_is_ready" doc="If protocol and parameter information has been obtained from the connection manager or the cache in the .manager file, return %TRUE. Otherwise, return %FALSE. This may change from %FALSE to %TRUE at any time that the main loop is running; the #GObject::notify signal is emitted for the #TpConnectionManager:info-source property." version="0.7.26">
        <return-value transfer-ownership="none" doc=" %TP_CM_INFO_SOURCE_NONE">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_running" c:identifier="tp_connection_manager_is_running" doc="Return %TRUE if this connection manager currently appears to be running. This may change at any time that the main loop is running; the #TpConnectionManager::activated and #TpConnectionManager::exited signals are emitted." version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_info_source" c:identifier="tp_connection_manager_get_info_source" doc="If protocol and parameter information has been obtained from the connection manager, return %TP_CM_INFO_SOURCE_LIVE; if it has been obtained from the cache in the .manager file, return %TP_CM_INFO_SOURCE_FILE. If this information has not yet been obtained, or obtaining it failed, return %TP_CM_INFO_SOURCE_NONE. This may increase at any time that the main loop is running; the #GObject::notify signal is emitted." version="0.7.26">
        <return-value transfer-ownership="full">
          <type name="CMInfoSource" c:type="TpCMInfoSource"/>
        </return-value>
      </method>
      <method name="dup_protocol_names" c:identifier="tp_connection_manager_dup_protocol_names" doc="Returns a list of protocol names supported by this connection manager. These are the internal protocol names used by the Telepathy specification (e.g. &quot;jabber&quot; and &quot;msn&quot;), rather than user-visible names in any particular locale. If this function is called before the connection manager information has been obtained, the result is always %NULL. Use tp_connection_manager_call_when_ready() to wait for this. The result is copied and must be freed by the caller, but it is not necessarily still true after the main loop is re-entered." version="0.7.26">
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="has_protocol" c:identifier="tp_connection_manager_has_protocol" doc="Return whether @protocol is supported by this connection manager. If this function is called before the connection manager information has been obtained, the result is always %FALSE. Use tp_connection_manager_call_when_ready() to wait for this." version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none" doc=" e.g. &quot;jabber&quot; or &quot;msn&quot;">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="tp_connection_manager_get_protocol" doc="Returns a structure representing a protocol, or %NULL if this connection manager does not support the specified protocol. If this function is called before the connection manager information has been obtained, the result is always %NULL. Use tp_connection_manager_call_when_ready() to wait for this. The result is not necessarily valid after the main loop is re-entered." version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="ConnectionManagerProtocol" c:type="TpConnectionManagerProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none" doc=" e.g. &quot;jabber&quot; or &quot;msn&quot;">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="always-introspect" writable="1" doc="If %TRUE, always introspect the connection manager as it comes online, even if we already have its info from a .manager file. Default %FALSE.">
        <type name="boolean" c:type="gboolean"/>
      </property>
      <property name="connection-manager" doc="The name of the connection manager, e.g. &quot;gabble&quot; (read-only).">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="info-source" doc="Where we got the current information on supported protocols (a #TpCMInfoSource). Since 0.7.26, the #GObject::notify signal is emitted for this property.">
        <type name="uint" c:type="guint"/>
      </property>
      <property name="manager-file" writable="1" construct="1" doc="The absolute path of the .manager file. If set to %NULL (the default), the XDG data directories will be searched for a .manager file of the correct name. If set to the empty string, no .manager file will be read.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="protocols">
        <type name="ConnectionManagerProtocol" c:type="TpConnectionManagerProtocol**"/>
      </field>
      <field name="running" bits="1">
        <type name="uint" c:type="unsigned int"/>
      </field>
      <field name="always_introspect" bits="1">
        <type name="uint" c:type="unsigned int"/>
      </field>
      <field name="info_source" bits="2">
        <type name="uint" c:type="unsigned int"/>
      </field>
      <field name="reserved_flags" bits="28">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="priv">
        <type name="ConnectionManagerPrivate" c:type="TpConnectionManagerPrivate*"/>
      </field>
      <glib:signal name="activated" doc="Emitted when the connection manager's well-known name appears on the bus.">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="exited" doc="Emitted when the connection manager's well-known name disappears from the bus or when activation fails.">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-info" doc="Emitted when the connection manager's capabilities have been discovered. This signal is not very helpful. Since 0.7.26, using tp_connection_manager_call_when_ready() instead is recommended.">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ConnectionManagerClass" c:type="TpConnectionManagerClass" glib:is-gtype-struct-for="ConnectionManager" doc="The class of a #TpConnectionManager." version="0.7.1">
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="priv">
        <type name="any" c:type="gpointer*"/>
      </field>
    </record>
    <callback name="ConnectionManagerListCb" c:type="TpConnectionManagerListCb" doc="Signature of the callback supplied to tp_list_connection_managers(). Since 0.7.26, tp_list_connection_managers() will wait for each #TpConnectionManager to become ready, so all connection managers passed to @callback will be ready (tp_connection_manager_is_ready() will return %TRUE) unless an error occurred while launching that connection manager." version="0.7.1">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cms" transfer-ownership="none" doc=" be unreferenced and the array will be freed after the callback returns, so the callback must reference any CMs it stores a pointer to), or %NULL on error">
          <type name="ConnectionManager" c:type="TpConnectionManager**"/>
        </parameter>
        <parameter name="n_cms" transfer-ownership="none" doc=" %NULL)">
          <type name="size_t" c:type="gsize"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ConnectionManagerParam" c:type="TpConnectionManagerParam" doc="Structure representing a connection manager parameter." version="0.7.1">
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="dbus_signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="default_value" writable="1">
        <type name="GObject.Value" c:type="GValue"/>
      </field>
      <field name="flags" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <method name="get_name" c:identifier="tp_connection_manager_param_get_name" doc="&lt;!-- --&gt;" version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_dbus_signature" c:identifier="tp_connection_manager_param_get_dbus_signature" doc="&lt;!-- --&gt;" version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_required" c:identifier="tp_connection_manager_param_is_required" doc="&lt;!-- --&gt;" version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_required_for_registration" c:identifier="tp_connection_manager_param_is_required_for_registration" doc="&lt;!-- --&gt;" version="0.7.26">
        <return-value transfer-ownership="none" doc=" (by setting the special &quot;register&quot; parameter to %TRUE)">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_secret" c:identifier="tp_connection_manager_param_is_secret" doc="&lt;!-- --&gt;" version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_dbus_property" c:identifier="tp_connection_manager_param_is_dbus_property" doc="&lt;!-- --&gt;" version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_default" c:identifier="tp_connection_manager_param_get_default" doc="Get the default value for this parameter, if there is one. If %FALSE is returned, @value is left uninitialized." version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" doc="#GValue into which the default's type and value are written">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ConnectionManagerPrivate" c:type="TpConnectionManagerPrivate">
    </record>
    <record name="ConnectionManagerProtocol" c:type="TpConnectionManagerProtocol" doc="Structure representing a protocol supported by a connection manager. Note that the size of this structure may change, so its size must not be relied on." version="0.7.1">
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <type name="ConnectionManagerParam" c:type="TpConnectionManagerParam*"/>
      </field>
      <field name="priv" writable="1">
        <type name="any" c:type="gpointer"/>
      </field>
      <method name="dup_param_names" c:identifier="tp_connection_manager_protocol_dup_param_names" doc="Returns a list of parameter names supported by this connection manager for this protocol. The result is copied and must be freed by the caller with g_strfreev()." version="0.7.26">
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="has_param" c:identifier="tp_connection_manager_protocol_has_param" doc="&lt;!-- no more to say --&gt;" version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_param" c:identifier="tp_connection_manager_protocol_get_param" doc="&lt;!-- no more to say --&gt;" version="0.7.26">
        <return-value transfer-ownership="none" doc=" supported">
          <type name="ConnectionManagerParam" c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_register" c:identifier="tp_connection_manager_protocol_can_register" doc="Return whether a new account can be registered on this protocol, by setting the special &quot;register&quot; parameter to %TRUE." version="0.7.26">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <callback name="ConnectionManagerWhenReadyCb" c:type="TpConnectionManagerWhenReadyCb" doc="Called as the result of tp_connection_manager_call_when_ready(). If the connection manager's protocol and parameter information could be retrieved, non-%NULL and @cm is not ready.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cm" transfer-ownership="none">
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none" doc=" would return %FALSE">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" doc=" tp_connection_manager_call_when_ready()">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionNameListCb" c:type="TpConnectionNameListCb" doc="Signature of the callback supplied to tp_list_connection_names()." version="0.7.1">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="names" transfer-ownership="none" doc=" or %NULL on error">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none" doc="or 0 on error">
          <type name="size_t" c:type="gsize"/>
        </parameter>
        <parameter name="cms" transfer-ownership="none" doc=" (e.g. &quot;gabble&quot;) in the same order as @names, or %NULL on error">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="protocols" transfer-ownership="none" doc=" Telepathy spec (e.g. &quot;jabber&quot;) in the same order as @names, or %NULL on error">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionPresenceType" c:type="TpConnectionPresenceType">
      <member name="unset" value="0" c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNSET"/>
      <member name="offline" value="1" c:identifier="TP_CONNECTION_PRESENCE_TYPE_OFFLINE"/>
      <member name="available" value="2" c:identifier="TP_CONNECTION_PRESENCE_TYPE_AVAILABLE"/>
      <member name="away" value="3" c:identifier="TP_CONNECTION_PRESENCE_TYPE_AWAY"/>
      <member name="extended_away" value="4" c:identifier="TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY"/>
      <member name="hidden" value="5" c:identifier="TP_CONNECTION_PRESENCE_TYPE_HIDDEN"/>
      <member name="busy" value="6" c:identifier="TP_CONNECTION_PRESENCE_TYPE_BUSY"/>
      <member name="unknown" value="7" c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNKNOWN"/>
      <member name="error" value="8" c:identifier="TP_CONNECTION_PRESENCE_TYPE_ERROR"/>
    </enumeration>
    <record name="ConnectionPrivate" c:type="TpConnectionPrivate">
    </record>
    <callback name="ConnectionRequestHandlesCb" c:type="TpConnectionRequestHandlesCb">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <type name="Handle" c:type="TpHandle*"/>
        </parameter>
        <parameter name="ids" transfer-ownership="none">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionStatus" c:type="TpConnectionStatus">
      <member name="connected" value="0" c:identifier="TP_CONNECTION_STATUS_CONNECTED"/>
      <member name="connecting" value="1" c:identifier="TP_CONNECTION_STATUS_CONNECTING"/>
      <member name="disconnected" value="2" c:identifier="TP_CONNECTION_STATUS_DISCONNECTED"/>
    </enumeration>
    <enumeration name="ConnectionStatusReason" c:type="TpConnectionStatusReason">
      <member name="none_specified" value="0" c:identifier="TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED"/>
      <member name="requested" value="1" c:identifier="TP_CONNECTION_STATUS_REASON_REQUESTED"/>
      <member name="network_error" value="2" c:identifier="TP_CONNECTION_STATUS_REASON_NETWORK_ERROR"/>
      <member name="authentication_failed" value="3" c:identifier="TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED"/>
      <member name="encryption_error" value="4" c:identifier="TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR"/>
      <member name="name_in_use" value="5" c:identifier="TP_CONNECTION_STATUS_REASON_NAME_IN_USE"/>
      <member name="cert_not_provided" value="6" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED"/>
      <member name="cert_untrusted" value="7" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED"/>
      <member name="cert_expired" value="8" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_EXPIRED"/>
      <member name="cert_not_activated" value="9" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED"/>
      <member name="cert_hostname_mismatch" value="10" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH"/>
      <member name="cert_fingerprint_mismatch" value="11" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH"/>
      <member name="cert_self_signed" value="12" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED"/>
      <member name="cert_other_error" value="13" c:identifier="TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR"/>
    </enumeration>
    <callback name="ConnectionWhenReadyCb" c:type="TpConnectionWhenReadyCb" doc="Signature of a callback passed to tp_connection_call_when_ready(), which will be called exactly once, when the connection becomes ready or invalid (whichever happens first)">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none" doc=" if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)">
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none" doc=" it was invalidated if it is now invalid">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DBusDaemon" c:type="TpDBusDaemon" doc="A subclass of #TpProxy that represents the D-Bus daemon. It mainly provides functionality to manage well-known names on the bus." version="0.7.1" parent="Proxy" glib:type-name="TpDBusDaemon" glib:get-type="tp_dbus_daemon_get_type" glib:type-struct="DBusDaemonClass">
      <constructor name="new" c:identifier="tp_dbus_daemon_new" doc="Returns a proxy for signals and method calls on a particular bus connection. Use tp_dbus_daemon_dup() instead if you just want a connection to the starter or session bus (which is almost always the right thing for Telepathy)." version="0.7.1">
        <return-value transfer-ownership="full" doc=" to which @connection is connected">
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="dup" c:identifier="tp_dbus_daemon_dup" doc="Returns a proxy for signals and method calls on the D-Bus daemon on which this process was activated (if it was launched by D-Bus service activation), or the session bus (otherwise). If it is not possible to connect to the appropriate bus, raise an error and return %NULL. The returned #TpDBusDaemon is cached; the same #TpDBusDaemon object will be returned by this function repeatedly, as long as at least one reference exists." version="0.7.26" throws="1">
        <return-value transfer-ownership="full" doc=" daemon, or %NULL">
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </function>
      <function name="init_known_interfaces" c:identifier="tp_dbus_daemon_init_known_interfaces" doc="Ensure that the known interfaces for TpDBusDaemon have been set up. This is done automatically when necessary, but for correct overriding of library interfaces by local extensions, you should call this function before calling tp_proxy_or_subclass_hook_on_interface_add() with first argument %TP_TYPE_DBUS_DAEMON." version="0.7.32">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="watch_name_owner" c:identifier="tp_dbus_daemon_watch_name_owner" doc="Arrange for @callback to be called with the owner of @name as soon as possible (which might even be before this function returns!), then again every time the ownership of @name changes. If multiple watches are registered for the same @name, they will be called in the order they were registered." version="0.7.1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="3" destroy="4">
            <type name="DBusDaemonNameOwnerChangedCb" c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call" doc=" cancelled due to tp_dbus_daemon_cancel_name_owner_watch()">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="cancel_name_owner_watch" c:identifier="tp_dbus_daemon_cancel_name_owner_watch" doc="If there was a previous call to tp_dbus_daemon_watch_name_owner() with exactly the given @name, @callback and @user_data, remove it. If more than one watch matching the details provided was active, remove only the most recently added one." version="0.7.1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="call" closure="3">
            <type name="DBusDaemonNameOwnerChangedCb" c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_name" c:identifier="tp_dbus_daemon_request_name" doc="Claim the given well-known name without queueing, allowing replacement or replacing an existing name-owner. This makes a synchronous call to the bus daemon." version="0.7.30" throws="1">
        <return-value transfer-ownership="none" doc=" an error occurred.">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="idempotent" transfer-ownership="none" doc=" already owns the name">
            <type name="boolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_name" c:identifier="tp_dbus_daemon_release_name" doc="Release the given well-known name. This makes a synchronous call to the bus daemon." version="0.7.30" throws="1">
        <return-value transfer-ownership="none" doc=" if an error occurred.">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unique_name" c:identifier="tp_dbus_daemon_get_unique_name" version="0.7.35">
        <return-value transfer-ownership="none" doc=" as long as this #TpDBusDaemon is">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="list_names" c:identifier="tp_dbus_daemon_list_names" doc="Call the ListNames method on the bus daemon, asynchronously. The @callback will be called from the main loop with a list of all the names (either unique or well-known) that exist on the bus. In versions of telepathy-glib that have it, this should be preferred instead of calling tp_cli_dbus_daemon_call_list_names(), since that function will result in wakeups for every NameOwnerChanged signal." version="0.7.35">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="3" destroy="4">
            <type name="DBusDaemonListNamesCb" c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call" doc=" has succeeded or failed, or after @weak_object has been destroyed">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none" doc=" it is destroyed, @callback will not be called at all">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_activatable_names" c:identifier="tp_dbus_daemon_list_activatable_names" doc="Call the ListActivatableNames method on the bus daemon, asynchronously. The @callback will be called from the main loop with a list of all the well-known names that are available for service-activation on the bus. In versions of telepathy-glib that have it, this should be preferred instead of calling tp_cli_dbus_daemon_call_list_activatable_names(), since that function will result in wakeups for every NameOwnerChanged signal." version="0.7.35">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="3" destroy="4">
            <type name="DBusDaemonListNamesCb" c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="any" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="call" doc=" has succeeded or failed, or after @weak_object has been destroyed">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none" doc=" it is destroyed, @callback will not be called at all">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="DBusDaemonClass" c:type="TpDBusDaemonClass" glib:is-gtype-struct-for="DBusDaemon" doc="The class of #TpDBusDaemon." version="0.7.1">
    </record>
    <callback name="DBusDaemonListNamesCb" c:type="TpDBusDaemonListNamesCb" doc="Signature of a callback for functions that list bus names." version="0.7.35">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="names" transfer-ownership="none" doc=" bus names, or %NULL on error">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3" doc=" tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" doc=" tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusDaemonNameOwnerChangedCb" c:type="TpDBusDaemonNameOwnerChangedCb" doc="The signature of the callback called by tp_dbus_daemon_watch_name_owner()." version="0.7.1">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="new_owner" transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3" doc=" tp_dbus_daemon_watch_name_owner()">
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusDaemonPrivate" c:type="TpDBusDaemonPrivate">
    </record>
    <enumeration name="DBusError" doc="#GError codes for use with the %TP_DBUS_ERRORS domain." version="0.7.1" c:type="TpDBusError">
      <member name="p_dbus_error_unknown_remote_error" value="0" c:identifier="TP_DBUS_ERROR_UNKNOWN_REMOTE_ERROR"/>
      <member name="p_dbus_error_proxy_unreferenced" value="1" c:identifier="TP_DBUS_ERROR_PROXY_UNREFERENCED"/>
      <member name="p_dbus_error_no_interface" value="2" c:identifier="TP_DBUS_ERROR_NO_INTERFACE"/>
      <member name="p_dbus_error_name_owner_lost" value="3" c:identifier="TP_DBUS_ERROR_NAME_OWNER_LOST"/>
      <member name="p_dbus_error_invalid_bus_name" value="4" c:identifier="TP_DBUS_ERROR_INVALID_BUS_NAME"/>
      <member name="p_dbus_error_invalid_interface_name" value="5" c:identifier="TP_DBUS_ERROR_INVALID_INTERFACE_NAME"/>
      <member name="p_dbus_error_invalid_object_path" value="6" c:identifier="TP_DBUS_ERROR_INVALID_OBJECT_PATH"/>
      <member name="p_dbus_error_invalid_member_name" value="7" c:identifier="TP_DBUS_ERROR_INVALID_MEMBER_NAME"/>
      <member name="p_dbus_error_object_removed" value="8" c:identifier="TP_DBUS_ERROR_OBJECT_REMOVED"/>
      <member name="p_dbus_error_cancelled" value="9" c:identifier="TP_DBUS_ERROR_CANCELLED"/>
      <member name="p_dbus_error_inconsistent" value="10" c:identifier="TP_DBUS_ERROR_INCONSISTENT"/>
      <member name="um_tp_dbus_errors" value="11" c:identifier="NUM_TP_DBUS_ERRORS"/>
    </enumeration>
    <constant name="DEFAULT_INCREMENT_LOG2" value="3">
      <type name="int"/>
    </constant>
    <enumeration name="DTMFEvent" c:type="TpDTMFEvent">
      <member name="digit_0" value="0" c:identifier="TP_DTMF_EVENT_DIGIT_0"/>
      <member name="digit_1" value="1" c:identifier="TP_DTMF_EVENT_DIGIT_1"/>
      <member name="digit_2" value="2" c:identifier="TP_DTMF_EVENT_DIGIT_2"/>
      <member name="digit_3" value="3" c:identifier="TP_DTMF_EVENT_DIGIT_3"/>
      <member name="digit_4" value="4" c:identifier="TP_DTMF_EVENT_DIGIT_4"/>
      <member name="digit_5" value="5" c:identifier="TP_DTMF_EVENT_DIGIT_5"/>
      <member name="digit_6" value="6" c:identifier="TP_DTMF_EVENT_DIGIT_6"/>
      <member name="digit_7" value="7" c:identifier="TP_DTMF_EVENT_DIGIT_7"/>
      <member name="digit_8" value="8" c:identifier="TP_DTMF_EVENT_DIGIT_8"/>
      <member name="digit_9" value="9" c:identifier="TP_DTMF_EVENT_DIGIT_9"/>
      <member name="asterisk" value="10" c:identifier="TP_DTMF_EVENT_ASTERISK"/>
      <member name="hash" value="11" c:identifier="TP_DTMF_EVENT_HASH"/>
      <member name="letter_a" value="12" c:identifier="TP_DTMF_EVENT_LETTER_A"/>
      <member name="letter_b" value="13" c:identifier="TP_DTMF_EVENT_LETTER_B"/>
      <member name="letter_c" value="14" c:identifier="TP_DTMF_EVENT_LETTER_C"/>
      <member name="letter_d" value="15" c:identifier="TP_DTMF_EVENT_LETTER_D"/>
    </enumeration>
    <enumeration name="DebugLevel" c:type="TpDebugLevel">
      <member name="error" value="0" c:identifier="TP_DEBUG_LEVEL_ERROR"/>
      <member name="critical" value="1" c:identifier="TP_DEBUG_LEVEL_CRITICAL"/>
      <member name="warning" value="2" c:identifier="TP_DEBUG_LEVEL_WARNING"/>
      <member name="message" value="3" c:identifier="TP_DEBUG_LEVEL_MESSAGE"/>
      <member name="info" value="4" c:identifier="TP_DEBUG_LEVEL_INFO"/>
      <member name="debug" value="5" c:identifier="TP_DEBUG_LEVEL_DEBUG"/>
    </enumeration>
    <enumeration name="DeliveryReportingSupportFlags" c:type="TpDeliveryReportingSupportFlags">
      <member name="failures" value="1" c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_FAILURES"/>
      <member name="successes" value="2" c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_SUCCESSES"/>
    </enumeration>
    <enumeration name="DeliveryStatus" c:type="TpDeliveryStatus">
      <member name="unknown" value="0" c:identifier="TP_DELIVERY_STATUS_UNKNOWN"/>
      <member name="delivered" value="1" c:identifier="TP_DELIVERY_STATUS_DELIVERED"/>
      <member name="temporarily_failed" value="2" c:identifier="TP_DELIVERY_STATUS_TEMPORARILY_FAILED"/>
      <member name="permanently_failed" value="3" c:identifier="TP_DELIVERY_STATUS_PERMANENTLY_FAILED"/>
      <member name="accepted" value="4" c:identifier="TP_DELIVERY_STATUS_ACCEPTED"/>
    </enumeration>
    <enumeration name="FileHashType" c:type="TpFileHashType">
      <member name="none" value="0" c:identifier="TP_FILE_HASH_TYPE_NONE"/>
      <member name="md5" value="1" c:identifier="TP_FILE_HASH_TYPE_MD5"/>
      <member name="sha1" value="2" c:identifier="TP_FILE_HASH_TYPE_SHA1"/>
      <member name="sha256" value="3" c:identifier="TP_FILE_HASH_TYPE_SHA256"/>
    </enumeration>
    <enumeration name="FileTransferState" c:type="TpFileTransferState">
      <member name="none" value="0" c:identifier="TP_FILE_TRANSFER_STATE_NONE"/>
      <member name="pending" value="1" c:identifier="TP_FILE_TRANSFER_STATE_PENDING"/>
      <member name="accepted" value="2" c:identifier="TP_FILE_TRANSFER_STATE_ACCEPTED"/>
      <member name="open" value="3" c:identifier="TP_FILE_TRANSFER_STATE_OPEN"/>
      <member name="completed" value="4" c:identifier="TP_FILE_TRANSFER_STATE_COMPLETED"/>
      <member name="cancelled" value="5" c:identifier="TP_FILE_TRANSFER_STATE_CANCELLED"/>
    </enumeration>
    <enumeration name="FileTransferStateChangeReason" c:type="TpFileTransferStateChangeReason">
      <member name="none" value="0" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_NONE"/>
      <member name="requested" value="1" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REQUESTED"/>
      <member name="local_stopped" value="2" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_STOPPED"/>
      <member name="remote_stopped" value="3" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_STOPPED"/>
      <member name="local_error" value="4" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_ERROR"/>
      <member name="remote_error" value="5" c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_ERROR"/>
    </enumeration>
    <enumeration name="HandleType" c:type="TpHandleType">
      <member name="none" value="0" c:identifier="TP_HANDLE_TYPE_NONE"/>
      <member name="contact" value="1" c:identifier="TP_HANDLE_TYPE_CONTACT"/>
      <member name="room" value="2" c:identifier="TP_HANDLE_TYPE_ROOM"/>
      <member name="list" value="3" c:identifier="TP_HANDLE_TYPE_LIST"/>
      <member name="group" value="4" c:identifier="TP_HANDLE_TYPE_GROUP"/>
    </enumeration>
    <callback name="IntFunc" c:type="TpIntFunc" doc="A callback function acting on unsigned integers.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="i" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IntSet" c:type="TpIntSet" doc="Opaque type representing a set of unsigned integers.">
    </record>
    <record name="IntSetIter" c:type="TpIntSetIter" doc="A structure representing iteration over a set of integers. Must be initialized with either TP_INTSET_ITER_INIT() or tp_intset_iter_init().">
      <field name="set" writable="1">
        <type name="IntSet" c:type="TpIntSet*"/>
      </field>
      <field name="element" writable="1">
        <type name="uint" c:type="guint"/>
      </field>
    </record>
    <enumeration name="LocalHoldState" c:type="TpLocalHoldState">
      <member name="unheld" value="0" c:identifier="TP_LOCAL_HOLD_STATE_UNHELD"/>
      <member name="held" value="1" c:identifier="TP_LOCAL_HOLD_STATE_HELD"/>
      <member name="pending_hold" value="2" c:identifier="TP_LOCAL_HOLD_STATE_PENDING_HOLD"/>
      <member name="pending_unhold" value="3" c:identifier="TP_LOCAL_HOLD_STATE_PENDING_UNHOLD"/>
    </enumeration>
    <enumeration name="LocalHoldStateReason" c:type="TpLocalHoldStateReason">
      <member name="none" value="0" c:identifier="TP_LOCAL_HOLD_STATE_REASON_NONE"/>
      <member name="requested" value="1" c:identifier="TP_LOCAL_HOLD_STATE_REASON_REQUESTED"/>
      <member name="resource_not_available" value="2" c:identifier="TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE"/>
    </enumeration>
    <constant name="MC5_BUS_NAME" value="org.freedesktop.Telepathy.MissionControl5">
      <type name="utf8"/>
    </constant>
    <enumeration name="MediaStreamBaseProto" c:type="TpMediaStreamBaseProto">
      <member name="udp" value="0" c:identifier="TP_MEDIA_STREAM_BASE_PROTO_UDP"/>
      <member name="tcp" value="1" c:identifier="TP_MEDIA_STREAM_BASE_PROTO_TCP"/>
    </enumeration>
    <enumeration name="MediaStreamDirection" c:type="TpMediaStreamDirection">
      <member name="none" value="0" c:identifier="TP_MEDIA_STREAM_DIRECTION_NONE"/>
      <member name="send" value="1" c:identifier="TP_MEDIA_STREAM_DIRECTION_SEND"/>
      <member name="receive" value="2" c:identifier="TP_MEDIA_STREAM_DIRECTION_RECEIVE"/>
      <member name="bidirectional" value="3" c:identifier="TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL"/>
    </enumeration>
    <enumeration name="MediaStreamError" c:type="TpMediaStreamError">
      <member name="unknown" value="0" c:identifier="TP_MEDIA_STREAM_ERROR_UNKNOWN"/>
      <member name="eos" value="1" c:identifier="TP_MEDIA_STREAM_ERROR_EOS"/>
      <member name="codec_negotiation_failed" value="2" c:identifier="TP_MEDIA_STREAM_ERROR_CODEC_NEGOTIATION_FAILED"/>
      <member name="connection_failed" value="3" c:identifier="TP_MEDIA_STREAM_ERROR_CONNECTION_FAILED"/>
      <member name="network_error" value="4" c:identifier="TP_MEDIA_STREAM_ERROR_NETWORK_ERROR"/>
      <member name="no_codecs" value="5" c:identifier="TP_MEDIA_STREAM_ERROR_NO_CODECS"/>
      <member name="invalid_cm_behavior" value="6" c:identifier="TP_MEDIA_STREAM_ERROR_INVALID_CM_BEHAVIOR"/>
      <member name="media_error" value="7" c:identifier="TP_MEDIA_STREAM_ERROR_MEDIA_ERROR"/>
    </enumeration>
    <enumeration name="MediaStreamPendingSend" c:type="TpMediaStreamPendingSend">
      <member name="local_send" value="1" c:identifier="TP_MEDIA_STREAM_PENDING_LOCAL_SEND"/>
      <member name="remote_send" value="2" c:identifier="TP_MEDIA_STREAM_PENDING_REMOTE_SEND"/>
    </enumeration>
    <enumeration name="MediaStreamState" c:type="TpMediaStreamState">
      <member name="disconnected" value="0" c:identifier="TP_MEDIA_STREAM_STATE_DISCONNECTED"/>
      <member name="connecting" value="1" c:identifier="TP_MEDIA_STREAM_STATE_CONNECTING"/>
      <member name="connected" value="2" c:identifier="TP_MEDIA_STREAM_STATE_CONNECTED"/>
    </enumeration>
    <enumeration name="MediaStreamTransportType" c:type="TpMediaStreamTransportType">
      <member name="local" value="0" c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL"/>
      <member name="derived" value="1" c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED"/>
      <member name="relay" value="2" c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY"/>
    </enumeration>
    <enumeration name="MediaStreamType" c:type="TpMediaStreamType">
      <member name="audio" value="0" c:identifier="TP_MEDIA_STREAM_TYPE_AUDIO"/>
      <member name="video" value="1" c:identifier="TP_MEDIA_STREAM_TYPE_VIDEO"/>
    </enumeration>
    <enumeration name="MessagePartSupportFlags" c:type="TpMessagePartSupportFlags">
      <member name="one_attachment" value="1" c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_ONE_ATTACHMENT"/>
      <member name="multiple_attachments" value="2" c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_MULTIPLE_ATTACHMENTS"/>
    </enumeration>
    <enumeration name="MessageSendingFlags" c:type="TpMessageSendingFlags">
      <member name="message_sending_flag_report_delivery" value="1" c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELIVERY"/>
    </enumeration>
    <constant name="NUM_TP_CHANNEL_CHAT_STATES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CHANNEL_GROUP_CHANGE_REASONS" value="12">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CHANNEL_TEXT_MESSAGE_TYPES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CHANNEL_TEXT_SEND_ERRORS" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CONNECTION_PRESENCE_TYPES" value="9">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CONNECTION_STATUSES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_CONNECTION_STATUS_REASONS" value="14">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_DEBUG_LEVELS" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_DELIVERY_STATUSES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_DTMF_EVENTS" value="16">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_FILE_HASH_TYPES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_FILE_TRANSFER_STATES" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_FILE_TRANSFER_STATE_CHANGE_REASONS" value="6">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_HANDLE_TYPES" value="5">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_LOCAL_HOLD_STATES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_LOCAL_HOLD_STATE_REASONS" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_BASE_PROTOS" value="2">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_DIRECTIONS" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_ERRORS" value="8">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_STATES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_TRANSPORT_TYPES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_MEDIA_STREAM_TYPES" value="2">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_RICH_PRESENCE_ACCESS_CONTROL_TYPES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_SOCKET_ACCESS_CONTROLS" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_SOCKET_ADDRESS_TYPES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_TUBE_CHANNEL_STATES" value="4">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_TUBE_STATES" value="3">
      <type name="int"/>
    </constant>
    <constant name="NUM_TP_TUBE_TYPES" value="2">
      <type name="int"/>
    </constant>
    <enumeration name="PropertyFlags" c:type="TpPropertyFlags">
      <member name="read" value="1" c:identifier="TP_PROPERTY_FLAG_READ"/>
      <member name="write" value="2" c:identifier="TP_PROPERTY_FLAG_WRITE"/>
    </enumeration>
    <class name="Proxy" c:type="TpProxy" doc="Structure representing a Telepathy client-side proxy." version="0.7.1" parent="GObject.Object" glib:type-name="TpProxy" glib:get-type="tp_proxy_get_type" glib:type-struct="ProxyClass">
      <method name="has_interface_by_id" c:identifier="tp_proxy_has_interface_by_id" doc="&lt;!-- --&gt;" version="0.7.1">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon" c:identifier="tp_proxy_get_dbus_daemon" doc="&lt;!-- --&gt;" version="0.7.17">
        <return-value transfer-ownership="full" doc=" always %NULL if this object is itself a #TpDBusDaemon. The caller must reference the returned object with g_object_ref() if it will be kept.">
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_dbus_connection" c:identifier="tp_proxy_get_dbus_connection" doc="&lt;!-- --&gt;" version="0.7.17">
        <return-value transfer-ownership="full" doc=" The caller must reference the returned pointer with dbus_g_connection_ref() if it will be kept.">
          <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
        </return-value>
      </method>
      <method name="get_bus_name" c:identifier="tp_proxy_get_bus_name" doc="&lt;!-- --&gt;" version="0.7.17">
        <return-value transfer-ownership="none" doc=" must copy the string with g_strdup() if it will be kept.">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_object_path" c:identifier="tp_proxy_get_object_path" doc="&lt;!-- --&gt;" version="0.7.17">
        <return-value transfer-ownership="none" doc=" string with g_strdup() if it will be kept.">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_invalidated" c:identifier="tp_proxy_get_invalidated" doc="&lt;!-- --&gt;" version="0.7.17">
        <return-value transfer-ownership="none" doc=" invalidated. The caller must copy the error, for instance with g_error_copy(), if it will be kept.">
          <type name="GLib.Error" c:type="GError*"/>
        </return-value>
      </method>
      <method name="dbus_error_to_gerror" c:identifier="tp_proxy_dbus_error_to_gerror" doc="Convert a D-Bus error name into a GError as if it was returned by a method on this proxy. This method is useful when D-Bus error names are emitted in signals, such as Connection.ConnectionError and Group.MembersChangedDetailed." version="0.7.24" throws="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dbus_error" transfer-ownership="none" doc=" tp_cli_connection_connect_to_connection_error()">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="debug_message" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus-name" writable="1" construct-only="1" doc="The D-Bus bus name for this object. Read-only except during construction.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <property name="dbus-connection" writable="1" construct-only="1" doc="The D-Bus connection for this object. Read-only except during construction.">
        <type name="DBusGLib.Connection" c:type="DBusGConnection"/>
      </property>
      <property name="dbus-daemon" writable="1" construct-only="1" doc="The D-Bus daemon for this object (this object itself, if it is a TpDBusDaemon). Read-only except during construction.">
        <type name="DBusDaemon" c:type="TpDBusDaemon"/>
      </property>
      <property name="interfaces" doc="Known D-Bus interface names for this object.">
        <type name="GObject.Strv" c:type="GStrv"/>
      </property>
      <property name="object-path" writable="1" construct-only="1" doc="The D-Bus object path for this object. Read-only except during construction.">
        <type name="utf8" c:type="gchararray"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="dbus_daemon">
        <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
      </field>
      <field name="dbus_connection">
        <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
      </field>
      <field name="bus_name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="invalidated">
        <type name="GLib.Error" c:type="GError*"/>
      </field>
      <field name="priv">
        <type name="ProxyPrivate" c:type="TpProxyPrivate*"/>
      </field>
      <glib:signal name="interface-added" doc="Emitted when this proxy has gained an interface. It is not guaranteed to be emitted immediately, but will be emitted before the interface is tp_proxy_borrow_interface_by_id(), any signal is connected, or any method is called). The intended use is to call dbus_g_proxy_add_signals(). This signal should only be used by TpProy implementations">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <type name="DBusGLib.Proxy" c:type="DBusGProxy"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidated" doc="Emitted when this proxy has been become invalid for whatever reason. Any more specific signal should be emitted first.">
        <return-value transfer-ownership="full">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <type name="uint" c:type="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <type name="int" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="gchararray"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ProxyClass" c:type="TpProxyClass" glib:is-gtype-struct-for="Proxy" doc="The class of a #TpProxy." version="0.7.1">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="interface">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="must_have_unique_name" bits="1">
        <type name="uint" c:type="unsigned int"/>
      </field>
      <field name="_reserved_flags" bits="31">
        <type name="uint" c:type="guint"/>
      </field>
      <field name="_reserved">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback"/>
        </array>
      </field>
      <field name="priv">
        <type name="any" c:type="gpointer"/>
      </field>
    </record>
    <record name="ProxyPendingCall" c:type="TpProxyPendingCall">
      <method name="cancel" c:identifier="tp_proxy_pending_call_cancel">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="ProxyPrivate" c:type="TpProxyPrivate">
    </record>
    <record name="ProxySignalConnection" c:type="TpProxySignalConnection">
      <method name="disconnect" c:identifier="tp_proxy_signal_connection_disconnect">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="RichPresenceAccessControlType" c:type="TpRichPresenceAccessControlType">
      <member name="whitelist" value="0" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_WHITELIST"/>
      <member name="publish_list" value="1" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_PUBLISH_LIST"/>
      <member name="group" value="2" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_GROUP"/>
      <member name="open" value="3" c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_OPEN"/>
    </enumeration>
    <enumeration name="SocketAccessControl" c:type="TpSocketAccessControl">
      <member name="localhost" value="0" c:identifier="TP_SOCKET_ACCESS_CONTROL_LOCALHOST"/>
      <member name="port" value="1" c:identifier="TP_SOCKET_ACCESS_CONTROL_PORT"/>
      <member name="netmask" value="2" c:identifier="TP_SOCKET_ACCESS_CONTROL_NETMASK"/>
      <member name="credentials" value="3" c:identifier="TP_SOCKET_ACCESS_CONTROL_CREDENTIALS"/>
    </enumeration>
    <enumeration name="SocketAddressType" c:type="TpSocketAddressType">
      <member name="unix" value="0" c:identifier="TP_SOCKET_ADDRESS_TYPE_UNIX"/>
      <member name="abstract_unix" value="1" c:identifier="TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX"/>
      <member name="ipv4" value="2" c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV4"/>
      <member name="ipv6" value="3" c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV6"/>
    </enumeration>
    <enumeration name="TubeChannelState" c:type="TpTubeChannelState">
      <member name="local_pending" value="0" c:identifier="TP_TUBE_CHANNEL_STATE_LOCAL_PENDING"/>
      <member name="remote_pending" value="1" c:identifier="TP_TUBE_CHANNEL_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_CHANNEL_STATE_OPEN"/>
      <member name="not_offered" value="3" c:identifier="TP_TUBE_CHANNEL_STATE_NOT_OFFERED"/>
    </enumeration>
    <enumeration name="TubeState" c:type="TpTubeState">
      <member name="local_pending" value="0" c:identifier="TP_TUBE_STATE_LOCAL_PENDING"/>
      <member name="remote_pending" value="1" c:identifier="TP_TUBE_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_STATE_OPEN"/>
    </enumeration>
    <enumeration name="TubeType" c:type="TpTubeType">
      <member name="dbus" value="0" c:identifier="TP_TUBE_TYPE_DBUS"/>
      <member name="stream" value="1" c:identifier="TP_TUBE_TYPE_STREAM"/>
    </enumeration>
    <constant name="UNKNOWN_CONNECTION_STATUS" value="-1">
      <type name="int"/>
    </constant>
    <function name="dbus_errors_quark" c:identifier="tp_dbus_errors_quark">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_disconnected_quark" c:identifier="tp_errors_disconnected_quark">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_removed_from_group_quark" c:identifier="tp_errors_removed_from_group_quark">
      <return-value transfer-ownership="full">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="handle_type_is_valid" c:identifier="tp_handle_type_is_valid" doc="If the given handle type is valid, return %TRUE. If not, set @error and return %FALSE." throws="1">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_to_string" c:identifier="tp_handle_type_to_string" doc="&lt;!----&gt;">
      <return-value transfer-ownership="none" doc=" For invalid handle types, returns &quot;(no handle)&quot; for 0 or &quot;(invalid handle type)&quot; for others.">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_add" c:identifier="tp_intset_add" doc="Add an integer into a TpIntSet.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="element" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_clear" c:identifier="tp_intset_clear" doc="Unset every integer in the set.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_copy" c:identifier="tp_intset_copy" doc="tp_intset_destroy() by the caller">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="orig" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_destroy" c:identifier="tp_intset_destroy" doc="Free all memory used by the set.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_difference" c:identifier="tp_intset_difference" doc="(analogous to the bitwise operation left &amp; (~right)), to be freed with tp_intset_destroy() by the caller">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_dump" c:identifier="tp_intset_dump" doc="numbers in @set in a human-readable format">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_foreach" c:identifier="tp_intset_foreach" doc="Call @func(element, @userdata) for each element of @set.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call" closure="2">
          <type name="IntFunc" c:type="TpIntFunc"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <type name="any" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_from_array" c:identifier="tp_intset_from_array">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <type name="GLib.Array" c:type="GArray*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_intersection" c:identifier="tp_intset_intersection" doc="(analogous to the bitwise operation left &amp; right), to be freed with tp_intset_destroy() by the caller">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_is_equal" c:identifier="tp_intset_is_equal">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_is_member" c:identifier="tp_intset_is_member" doc="Tests if @element is a member of @set">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="element" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_iter_next" c:identifier="tp_intset_iter_next" doc="If there are integers in (@iter-&gt;set) higher than (@iter-&gt;element), set (iter-&gt;element) to the next one and return %TRUE. Otherwise return %FALSE. Usage: &lt;informalexample&gt;&lt;programlisting&gt; TpIntSetIter iter = TP_INTSET_INIT (intset); while (tp_intset_iter_next (&amp;amp;iter)) { printf (&quot;%u is in the intset\n&quot;, iter.element); } &lt;/programlisting&gt;&lt;/informalexample&gt;">
      <return-value transfer-ownership="none" doc="has been advanced">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <type name="IntSetIter" c:type="TpIntSetIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_new" c:identifier="tp_intset_new" doc="Allocate a new integer set with a default memory allocation.">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
    </function>
    <function name="intset_new_containing" c:identifier="tp_intset_new_containing" doc="Allocate a new integer set containing the given integer. tp_intset_destroy()">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_remove" c:identifier="tp_intset_remove" doc="Remove an integer from a TpIntSet">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="element" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_size" c:identifier="tp_intset_size">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_sized_new" c:identifier="tp_intset_sized_new" doc="Allocate an integer set just large enough to store the given number of bits, rounded up as necessary. The set will still expand automatically if you store larger integers; this is just an optimization to avoid wasting memory (if the set is too large) or time (if the set is too small and needs reallocation).">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <type name="uint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_symmetric_difference" c:identifier="tp_intset_symmetric_difference" doc="but not both (analogous to the bitwise operation left ^ right), to be freed with tp_intset_destroy() by the caller">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_to_array" c:identifier="tp_intset_to_array" doc="the same integers as @set.">
      <return-value transfer-ownership="full" doc="containing">
        <type name="GLib.Array" c:type="GArray*"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intset_union" c:identifier="tp_intset_union" doc="(analogous to the bitwise operation left | right), to be freed with tp_intset_destroy() by the caller">
      <return-value transfer-ownership="full">
        <type name="IntSet" c:type="TpIntSet*"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="IntSet" c:type="TpIntSet*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers" c:identifier="tp_list_connection_managers" doc="List the available (running or installed) connection managers. Call the callback when done. Since 0.7.26, this function will wait for each #TpConnectionManager to be ready, so all connection managers passed to @callback will be ready (tp_connection_manager_is_ready() will return %TRUE) unless an error occurred while launching that connection manager." version="0.7.1">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3" doc=" not called if the @weak_object goes away">
          <type name="ConnectionManagerListCb" c:type="TpConnectionManagerListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="call">
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" doc=" not be called, and the call will be cancelled, if the object has vanished">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_names" c:identifier="tp_list_connection_names" doc="List the bus names of all the connections that currently exist, together with the connection manager name and the protocol name for each connection. Call the callback when done. The bus names passed to the callback can be used to construct #TpConnection objects for any connections that are of interest." version="0.7.1">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3" doc=" fails; not called if the D-Bus connection fails completely or if the">
          <type name="ConnectionNameListCb" c:type="TpConnectionNameListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <type name="any" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="call">
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" doc=" not be called if the object has vanished">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
